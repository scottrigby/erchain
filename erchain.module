<?php

/**
 * @file
 * Hook implementations and API functions for Entityreference chain module.
 */

/**
 * Implements hook_theme().
 */
function erchain_theme() {
  return array(
    'erchain_none' => array(
      'variables' => array('option' => NULL),
    ),
  );
}

/**
 * Returns HTML for the label for the empty value for options that are not
 * required.
 *
 * @see theme_options_none()
 */
function theme_erchain_none($variables) {
  $output = ($variables['option'] == 'option_none' ? t('- None -') : t('- Select a value -'));
  return $output;
}

/**
 * Implements hook_field_widget_info().
 */
function erchain_field_widget_info() {
  return array(
    'erchain' => array(
      'label' => t('Entityreference chain'),
      'field types' => array('entityreference'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 * We build our own widget entirely for this function, because
 * hook_field_widget_form_alter() does not give us the form object for
 * ajax-rebuilding.
 */
function erchain_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Abstract over the actual field columns, to allow different field types to
  // reuse those widgets.
  $value_key = key($field['columns']);
  $type = "select";
  $multiple = 1;
  $required = $element['#required'];
  $has_value = isset($items[0][$value_key]);
  $properties = _options_properties($type, $multiple, $required, $has_value);

  // Prepare the list of options.
  $options = _erchain_get_options($field, $instance, $properties, NULL, NULL);

  // Build on the existing element before adding our additions.
  $widget = $element;

  // Add faux select(s) which AJAX reload the actual Entityreference select.
  // @todo Set default value from child selection.
  // @todo Allow a longer chain.
  $faux_select = array(
    '#type' => 'select',
    '#options' => array(1,2,3),
    '#ajax' => array(
      'callback' => 'erchain_ajax_callback',
      'wrapper' => 'erchain-' . $delta,
      'effect' => 'fade',
    ),
    // @todo Consider a more elegant wrapper, without breaking stored values.
    '#prefix' => '<div class="container-inline">',
  );
  $element['erchain_faux_select'] = $faux_select;

  $widget += array(
    '#type' => 'select',
    '#default_value' => isset($items[$delta][$value_key]) ? $items[$delta][$value_key] : NULL,
    '#options' => $options,
    '#element_validate' => array('erchain_widget_validate'),
    '#value_key' => $value_key,
    '#properties' => $properties,
    '#prefix' => '<div id="erchain-' . $delta . '">',
    '#suffix' => '</div></div>',
  );
  $element[$value_key] = $widget;

  return $element;
}

/**
 * Ajax callback.
 */
function erchain_ajax_callback($form, $form_state) {
  $form_state['rebuild'] = TRUE;
  $parents = $form_state['triggering_element']['#array_parents'];
  array_pop($parents);
  $element = drupal_array_get_nested_value($form, $parents);

  // Filter the element options based on the faux selection.
  _erchain_filter_options($form_state['triggering_element']['#value'], $element['target_id']);

  // Explicitly return the Entityreference target_id.
  return $element['target_id'];
}

/**
 * Form element validation handler for options element.
 *
 * @see options_field_widget_validate()
 */
function erchain_widget_validate($element, &$form_state) {
  $properties = $element['#properties'];
  $value = $element['#value'];

  if ($element['#required'] && $element['#value'] == '_none') {
    form_error($element, t('!name field is required.', array('!name' => $element['#title'])));
  }

  if ($properties['empty_option']) {
    if ($value == '_none') {
      form_set_value($element, NULL, $form_state);
    }
  }
}

/**
 * Implements hook_field_widget_error().
 */
function erchain_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Collects the options for a field.
 *
 * @see _options_get_options()
 */
function _erchain_get_options($field, $instance, $properties, $entity_type, $entity) {
  // Get the list of options.
  $options = (array) module_invoke($field['module'], 'options_list', $field, $instance, $entity_type, $entity);

  // Sanitize the options.
  _options_prepare_options($options, $properties);

  if (!$properties['optgroups']) {
    $options = options_array_flatten($options);
  }

  if ($properties['empty_option']) {
    $label = theme('erchain_none', array('option' => $properties['empty_option']));
    $options = array('_none' => $label) + $options;
  }

  return $options;
}

/**
 * Gets faux form element(s).
 *
 * @todo Set options from configuration (determining the hierarchy structure).
 *
 * @see field_ui_default_value_widget()
 */
function _erchain_faux_element(&$element, &$form_state) {
  $entity_type = 'node';
  $bundle_name = 'season';
  $field_name = 'field_show';
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);
  $items = $instance['default_value'];
  $field = field_info_field($field_name);

  $instance['required'] = FALSE;
  $instance['description'] = '';

  // Stick to an empty 'parents' on this form in order not to breaks widgets
  // that do not use field_widget_[field|instance]() and still access
  // $form_state['field'] directly.
  $element['#parents'] = array();
  
  $faux_select = field_default_form($instance['entity_type'], NULL, $field, $instance, LANGUAGE_NONE, $items, $element, $form_state, 0);

  return $faux_select;
}

/**
 * Gets faux erchain select options.
 */
function _erchain_filter_options($selection, &$element) {
  // Get default field values.
  

}
