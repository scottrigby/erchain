<?php

/**
 * @file
 * Hook implementations and API functions for Entityreference chain module.
 */

/**
 * Implements hook_form_FORM_ID_alter().
 */
function erchain_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  // Only allow erchain_parent selection on fields configured to use the
  // multiple_selects widget.
  if ($form['#instance']['widget']['module'] != 'multiple_selects') {
    return;
  }

  $form['instance']['erchain_parent'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entityreference chain parent field'),
    // Add stable wrapper ID.
    '#prefix' => '<div id="erchain-parent-wrapper">',
    '#suffix' => '</div>',
  );

  $ajax = array(
    '#ajax' => array(
      'callback' => 'erchain_field_ui_field_edit_form_ajax_callback',
      'wrapper' => 'erchain-parent-wrapper',
      'effect' => 'fade',
    ),
  );

  $entity_type_options = array();
  $entity_type_info = entity_get_info();
  foreach ($entity_type_info as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }
  $form['instance']['erchain_parent']['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Entity type'),
    '#options' => $entity_type_options,
    '#default_value' => isset($form['#instance']['erchain_parent']['entity_type']) ? $form['#instance']['erchain_parent']['entity_type'] : '',
    '#description' => t('The Entityreference chain parent field entity type.'),
    '#empty_option' => t('- None -'),
  ) + $ajax;

  // Display of bundle is determined by entity type select - both the stored and
  // active selection values:
  // - Until change, the bundle select should display only if an entity type
  //   value is stored.
  // - On change, the bundle select should display only if entity type selection
  //   is not 'none' (should show/hide depending on this).
  // @todo Is there a simpler way to set this display criteria?
  $entity_type_selected = isset($form_state['input']['instance']['erchain_parent']['entity_type']);
  $entity_type_stored = isset($form['#instance']['erchain_parent']['entity_type']) && !empty($form['#instance']['erchain_parent']['entity_type']);
  $entity_type_selection = $entity_type_selected ? $form_state['input']['instance']['erchain_parent']['entity_type'] :
    ($entity_type_stored ? $form['#instance']['erchain_parent']['entity_type'] : '');

  if ($entity_type_selection) {
    $form['instance']['erchain_parent']['erchain_direction'] = array(
      '#type' => 'select',
      '#title' => t('Entityreference direction'),
      '#options' => array(
        'referencing' => t('Referencing'),
        // @todo Uncomment this option once 'referenced' is supported in
        //   erchain_filter_element_options().
        #'referenced' => t('Referenced'),
      ),
      '#default_value' => isset($form['#instance']['erchain_parent']['erchain_direction']) ? $form['#instance']['erchain_parent']['erchain_direction'] : '',
      '#description' => t('The Entityreference chain reference direction.'
        . '"Referencing" limits to entities referencing the parent selection.'
        . '"Referenced" limits to entities referenced by the parent.'),
    );

    $bundles = $entity_type_info[$entity_type_selection]['bundles'];
    $bundle_options = array();
    foreach ($bundles as $bundle => $bundle_info) {
      $bundle_options[$bundle] = $bundle_info['label'];
    }
    $form['instance']['erchain_parent']['bundle'] = array(
      '#type' => 'select',
      '#title' => t('Bundle'),
      '#options' => $bundle_options,
      '#default_value' => isset($form['#instance']['erchain_parent']['bundle']) ? $form['#instance']['erchain_parent']['bundle'] : '',
      '#description' => t('The Entityreference chain parent field bundle.'),
      '#empty_option' => t('- None -'),
      '#required' => TRUE,
    ) + $ajax;
  }

  // Display of field is determined by bundle select - both stored and active
  // values. Follows same logic as bundle element display above, with the
  // additional criteria that it should also hide when entity type is 'none'.
  $bundle_selected = isset($form_state['input']['instance']['erchain_parent']['bundle']);
  $bundle_stored = isset($form['#instance']['erchain_parent']['bundle']) && !empty($form['#instance']['erchain_parent']['bundle']);
  $bundle_selection = $bundle_selected ? $form_state['input']['instance']['erchain_parent']['bundle'] :
    ($bundle_stored ? $form['#instance']['erchain_parent']['bundle'] : '');

  if ($entity_type_selection && $bundle_selection) {
    $instances = field_info_instances($entity_type_selection, $bundle_selection);
    $field_options = array();
    foreach ($instances as $instance => $instance_info) {
      // Limit to only Entityreference fields.
      $field_info = field_info_field($instance_info['field_name']);
      if ($field_info['module'] == 'entityreference') {
        $field_options[$instance] = $instance_info['label'];
      }
    }
    $form['instance']['erchain_parent']['field_name'] = array(
      '#type' => 'select',
      '#title' => t('Field'),
      '#options' => $field_options,
      '#default_value' => isset($form['#instance']['erchain_parent']['field_name']) ? $form['#instance']['erchain_parent']['field_name'] : '',
      '#description' => t('The Entityreference chain parent field.'),
      '#empty_option' => t('- None -'),
      '#required' => TRUE,
    );
  }
}

/**
 * Ajax callback for field_ui_field_edit_form().
 */
function erchain_field_ui_field_edit_form_ajax_callback($form, $form_state) {
  // Find the parent element.
  $form_state['rebuild'] = TRUE;
  $parents = $form_state['triggering_element']['#array_parents'];
  array_pop($parents);
  $element = drupal_array_get_nested_value($form, $parents);

  return $element;
}

 /**
 * Gets a chain of Entityreference parent instances.
 *
 * @param array $instance
 *   A field instance array.
 * @param array $parents_instances
 *   Internal. An array of parent field instance arrays.
 *
 * @return array
 *   An array of field instance data arrays, representing a chain of configured
 *   entityreference fields from lowest to highest parent.
 *
 */
function erchain_get_parent_instances($instance, &$parents_instances = array()) {
  if (isset($instance['erchain_parent'])) {
    // @todo Ensure empty keys are not saved so we don't have to check this.
    if (!empty($instance['erchain_parent']['entity_type'])
      && !empty($instance['erchain_parent']['bundle'])
      && !empty($instance['erchain_parent']['field_name'])) {

      extract($instance['erchain_parent']);
      $parent_instance = field_info_instance($entity_type, $field_name, $bundle);
      // @todo Add erchain_direction configuration once we support 
      //   'referencing'. For now set this option explicitly.
      $parent_instance['erchain_direction'] = isset($instance['erchain_parent']['erchain_direction']) ? $instance['erchain_parent']['erchain_direction'] : 'referenced';
      // We add a child key, so that in
      // erchain_field_widget_multiple_selects_form_alter():
      //   - We can identify the lowest item in the chain (the actual
      //     entityreference field)
      //   - Each parent can target it's child's key to filter options when
      //     looping through the chain.
      $parent_instance['erchain_child'] = implode('__', array($instance['entity_type'], $instance['bundle'], $instance['field_name']));
      array_push($parents_instances, $parent_instance);
      erchain_get_parent_instances($parent_instance, $parents_instances);
    }
  }

  return $parents_instances;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * @todo Support parent multiple cardinality (Unsupported operand types error).
 */
function erchain_field_widget_multiple_selects_form_alter(&$element, &$form_state, $context) {
  // Check if the element is configured to have an erchain parent.
  // Note, that since we load parent elements using the Field API, this function
  // will also run for each of those.
  if (isset($context['instance']['erchain_parent'])
    // @todo Ensure empty keys are not saved so we don't have to check this.
    && !empty($context['instance']['erchain_parent']['entity_type'])
    && !empty($context['instance']['erchain_parent']['bundle'])
    && !empty($context['instance']['erchain_parent']['field_name'])
    // Check is this is the bottom of the chain (the actual entityreference
    // field). On parent elements, we'll only have that current element to
    // alter, rather than the actual Entityreference element anymore. So we need
    // to only act on the lowest child, and loop over each item in the chain of
    // parents.
    && !isset($context['instance']['erchain_child'])) {

    // Get the chain of Entityreference parent instances.
    $parents_instances = erchain_get_parent_instances($context['instance']);

    // Add stable wrapper ID to only the actual Entityreference.
    // @todo make inline class configurable. For now, we want it.
    $element['#prefix'] = '<div class="container-inline" id="erchain-parent-wrapper-' . $context['delta'] . '">';
    $element['#suffix'] = '</div>';

    $weight = 0;
    foreach ($parents_instances as $parent_position => $parent_instance) {
      // Add the parent field to the existing element.
      $parent_element = erchain_get_parent_element($parent_instance);
      $parent_element += array(
        '#ajax' => array(
          'callback' => 'erchain_field_ui_field_edit_form_ajax_callback',
          'wrapper' => 'erchain-parent-wrapper-' . $context['delta'],
          'effect' => 'fade',
        ),
        // The target_id element has 0 weight. So each new parent element in the
        // chain should be lighter than the last.
        '#weight' => $weight - 1,
      );
      $weight --;
      $parent_id = implode('__', array($parent_element['#entity_type'], $parent_element['#bundle'], $parent_element['#field_name']));
      $element[$parent_id] = $parent_element;

      // Set parent default value from saved actual Entityreference field value.
      // @todo Do this more generically.
      // @todo Go all the way up the chain with this.
      if (!empty($context['form']['#entity']->{$element['#field_name']}[LANGUAGE_NONE][$context['delta']]['target_id'])) {
        // @todo entity_load more generically. For now node_load works for us.
        $selected = node_load($context['form']['#entity']->{$element['#field_name']}[LANGUAGE_NONE][$context['delta']]['target_id']);
        // Grab the first values if there are multiple.
        if (isset($selected->{$parent_instance['field_name']})) {
          $first = reset($selected->{$parent_instance['field_name']}[LANGUAGE_NONE]);
          $element[$parent_id]['#default_value'] = $first['target_id'];
        }
      }

      // AJAX trigger.
      // Change the immediate child values based on this element's selection.
      // This will only happen on Ajax submit.
      // @todo Filter options on load (if an entity has the actual
      //   Entityreference saved with a value), and not only on AJAX trigger.
      $parent_element_ajax_triggered = isset($form_state['input'][$element['#field_name']][LANGUAGE_NONE][$context['delta']][$parent_id]);
      $parent_element_ajax_value = $parent_element_ajax_triggered ? $form_state['input'][$element['#field_name']][LANGUAGE_NONE][$context['delta']][$parent_id] : NULL;
      if ($parent_element_ajax_triggered) {
        // Override default value on AJAX trigger.
        $element[$parent_id]['#default_value'] = $parent_element_ajax_value;

        // Temporary fix for visible $element['_weight'] field after AJAX
        // trigger on entity forms.
        // @todo Debug this more thoroughly. So far:
        //   - '_weight' added in field_multiple_value_form(), just before
        //     invocation of hook_field_widget_WIDGET_TYPE_form_alter()
        //   - Later should be unset in _field_sort_items()
        // @todo Debug this more thoroughly. For now, just hide it.
        $element['_weight']['#attributes']['class'][] = 'js-hide';
      }
      
      // Check if this is the first item in the parents chain. If so, the
      // child should be the actual Entityreference element.
      $value_key = key($context['field']['columns']);
      $child_id = $parent_position == 0 ? $value_key : $parent_instance['erchain_child'];

      // Check for a parent selection, whether stored or AJAX triggered. Unless
      // either of these two conditions are met, the parent element
      // '#default_value' will be empty.
      $parent_empty_option = $element[$parent_id]['#default_value'] == '_none';
      $parent_empty_value = empty($element[$parent_id]['#default_value']);
      if ($parent_empty_option || $parent_empty_value) {
        // If there is no parent selection stored or AJAX triggered, or if the
        // value is _none, hide the child field.
        // @todo Ensure the child field does not store a value.
        $element[$child_id]['#value'] = '_none';
        $element[$child_id]['#access'] = FALSE;
      }
      else {
        // Temporarily stash the ER erchain_direction on the element for the
        // query to filter the options properly.
        $element[$parent_id]['#erchain_direction'] = $parent_instance['erchain_direction'];

        // Filter child options based on parent selection.
        erchain_filter_element_options($element[$parent_id], $element[$child_id]);

        // If parent is selected, we want to make child selection required. See
        // form_process_select(). Also fixes issue where a required
        // multiple_selects field looses the empty option on form cache such as
        // entity preview.
        $element[$child_id]['#required'] = TRUE;
        $element[$child_id]['#empty_value'] = '';
        $element[$child_id]['#empty_option'] = t('- Select -');
        if (isset($element[$child_id]['#options']['_none'])) {
          unset($element[$child_id]['#options']['_none']);
        }
      }
    }
  }
}

/**
 * Filters Season Entityreference options by selected show.
 *
 * @param array $triggering
 *   The trigering element array. In addition to the normal element data,
 *   there are also two more keys:
 *   - #erchain_direction: The configured reference direction
 *   - #default_value: The selected value
 * @param array $element
 *   By reference. The triggered element array whose options will be filtered.
 */
function erchain_filter_element_options($triggering, &$element) {
  // Get default field values.
  list($entity_type, $bundle, $field_name, $erchain_direction, $selected) = array($triggering['#entity_type'], $triggering['#bundle'], $triggering['#field_name'], $triggering['#erchain_direction'], $triggering['#default_value']);

  $ids = array();
  switch ($erchain_direction) {
    case 'referencing':
      // @todo limit query by the entity types / bundles which contain ER fields
      //   who's settings allow referecing the selected entity type / bundle.
      $query = new EntityFieldQuery();
      $query->fieldCondition($field_name, 'target_id', $selected, '=')
        // Run the query as user 1.
        ->addMetaData('account', user_load(1));
      $result = $query->execute();
      if (isset($result[$entity_type])) {
        $ids = array_keys($result[$entity_type]);
      }
      break;
    case 'referenced':
      // @todo Seems like a useful option for future.
      break;
  }

  // Reduce from existing options, which already pass access checks.
  foreach (array_keys($element['#options']) as $key) {
    if ($key != '_none' && !in_array($key, $ids)) {
      unset($element['#options'][$key]);
    }
  }
}

/**
 * Gets a field instance from an array of parent info.
 *
 * @param array $parent_info
 *   An associative array of information about the a parent Entityreference
 *   field element, containing:
 *   - entity_type: The entity type containing the parent field.
 *   - bundle: The bundle containing the parent field.
 *   - field_name: The parent field name.
 *   - erchain_direction: The entityreference erchain_direction. Can be:
 *     - referencing: Limit to entities referencing the parent selection.
 *     - referenced: Limit to entities referenced by the parent.
 *
 * @return array
 *   An array of field instance data.
 */
function erchain_get_parent_instance($parent_info) {
  extract($parent_info);
  $field = field_info_field($field_name);
  return field_info_instance($entity_type, $field_name, $bundle);
}

/**
 * Gets faux form element(s).
 *
 * @param array $instance
 *   A field instance array.
 *
 * @return array
 *   An unattached (faux) parent element in the select chain.
 *
 * @see field_ui_default_value_widget()
 */
function erchain_get_parent_element($instance) {
  $field = field_info_field($instance['field_name']);

  // Shortcut so we can just re-use field_ui_default_value_widget().
  $form = array();
  $form_state = array();
  module_load_include('inc', 'field_ui', 'field_ui.admin');
  $element = field_ui_default_value_widget($field, $instance, $form, $form_state);

  // Return just the element itself, without the wrapping default form markup.
  // Only return the first delta in a multi-delta field, because this will only
  // be used for selection not storage.
  $value_key = key($field['columns']);
  // The multiple_selects module always returns an array, regardless of
  // cardinality.
  return $element[$instance['field_name']][LANGUAGE_NONE][0][$value_key];
}
